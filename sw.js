importScripts('https://gcore.jsdelivr.net/npm/workbox-sw/build/workbox-sw.js');

if (workbox) {
    console.log('workboxÂä†ËΩΩÊàêÂäüüéâ');
} else {
    console.log('workboxÂä†ËΩΩÂ§±Ë¥•üò¨');
}

// Force production builds ÊòØÂê¶ÂÖ≥Èó≠ÊéßÂà∂Âè∞‰∏≠ÁöÑËæìÂá∫
workbox.setConfig({
    debug: true,
});

// self.__WB_DISABLE_DEV_LOGS = true;

//ËÆæÁΩÆÁºìÂ≠òcachestorageÁöÑÂêçÁß∞
workbox.core.setCacheNameDetails({
    prefix: 'CCÁöÑÈÉ®ËêΩÊ†º',
    suffix: 'ÁºìÂ≠ò',
    precache: 'Á¶ªÁ∫øÂêéÂ§á',
    runtime: 'ËøêË°åÊó∂',
    googleAnalytics: 'Ë∞∑Ê≠åÂàÜÊûê'
});

//Áõ¥Êé•ÊøÄÊ¥ªË∑≥ËøáÁ≠âÂæÖÈò∂ÊÆµ
self.skipWaiting();
workbox.core.clientsClaim();
// self.clients.claim();

// ÈÄöÂ∏∏ÂΩìÁî®Êà∑ÊãúËÆø / Êó∂ÔºåÂØπÂ∫îÁöÑÊãúËÆøÁöÑÈ°µÈù¢ HTML Êñá‰ª∂ÊòØ /index.htmlÔºåÈªòËÆ§Áä∂ÂÜµ‰∏ãÔºåprecache Ë∑ØÁî±Êú∫Âà∂‰ºöÂú®‰ªª‰Ωï URL ÁöÑÁªìÂ∞æÁöÑ / ÂêéÂä†‰∏ä index.htmlÔºåËøôÂ∞±ËÆ§‰∏∫ÁùÄ‰Ω†È¢ÑÁºìÂ≠òÁöÑ‰ªª‰Ωï index.html ÈÉΩËÉΩÂ§üÈÄöËøá /index.html ÊàñËÄÖ / ÊãúËÆøÂà∞„ÄÇÂΩìÁÑ∂Ôºå‰Ω†‰πüËÉΩÂ§üÈÄöËøá directoryIndex ÂèÇÊï∞Á¶ÅÁî®ÊéâËøô‰∏™ÈªòËÆ§Ë°å‰∏∫

workbox.precaching.precacheAndRoute(self.__WB_MANIFEST, {
    ignoreUrlParametersMatching: [/.*/],
    directoryIndex: null,
});

workbox.precaching.cleanupOutdatedCaches();

// Á¶ªÁ∫øÂêéÂ§áÊñπÂºè 1 ÈúÄÂêåÊ≠•ÈÖçÁΩÆÂπ∂ÂºÄÂêØÈ¢ÑÁºìÂ≠ò‰∏îÂØºËà™È¢ÑÂä†ËΩΩÂπ∂ÈùûÊâÄÊúâÊµèËßàÂô®ÊîØÊåÅ https://caniuse.com/mdn-api_navigationpreloadmanager_enable
// Enable navigation preload.

workbox.navigationPreload.enable();

// The network-only callback should match navigation requests, and
// the handler for the route should use the network-only strategy, but
// fall back to a precached offline page in case the user is offline.

const Offline = new workbox.routing.Route(({ request }) => {
    return request.mode === 'navigate';
}, new workbox.strategies.NetworkOnly({
    plugins: [
        new workbox.precaching.PrecacheFallbackPlugin({
            fallbackURL: 'offline/index.html'
        })
    ]
}));

workbox.routing.registerRoute(Offline);

// Á¶ªÁ∫øÂêéÂ§áÊñπÂºè 2 ÂìçÂ∫îË∂ÖÊó∂5ÁßíÂêé,Ë∑≥ËΩ¨Âà∞Á¶ªÁ∫øÈ°µÈù¢

// Hardcode the fallback cache name and the offline
// HTML fallback's URL for failed responses

// const FALLBACK_CACHE_NAME = 'Á¶ªÁ∫øÂêéÂ§á';
// const FALLBACK_HTML = '/offline/index.html';

// // Cache the fallback HTML during installation.

// self.addEventListener('install', (event) => {
//     event.waitUntil(
//         caches.open(FALLBACK_CACHE_NAME).then((cache) => cache.add(FALLBACK_HTML)),
//     );
// });

// Apply a network-only strategy to navigation requests.
// If offline, or if more than five seconds pass before there's a
// network response, fall back to the cached offline HTML.

// const Timeout = new workbox.strategies.NetworkOnly({
//     networkTimeoutSeconds: 5,
//     plugins: [
//         {
//             handlerDidError: async () => {
//                 return await caches.match(FALLBACK_HTML, {
//                     cacheName: FALLBACK_CACHE_NAME,
//                 });
//             },
//         },
//     ],
// });

// Register the route to handle all navigations.

// workbox.routing.registerRoute(new workbox.routing.NavigationRoute(Timeout));

// Á¶ªÁ∫øÂêéÂ§áÊñπÊ°à 3 ÁªºÂêàÂêéÂ§áËØ∑ÂèÇËÄÉhttps://developer.chrome.com/docs/workbox/managing-fallback-responses/
// Â¶ÇÊûúÊÇ®ÈúÄË¶ÅÂÅöÁöÑÂè™ÊòØÊèê‰æõ‰∏Ä‰∏™Ëá™ÂÆö‰πâÁöÑÁ¶ªÁ∫ø HTML È°µÈù¢Ôºå‰ΩÜÂà´Êó†ÂÖ∂‰ªñÔºåËøôÈáåÊúâ‰∏Ä‰∏™ÊÇ®ÂèØ‰ª•ÈÅµÂæ™ÁöÑÂü∫ÂáÜÈÖçÁΩÆÔºö
// ÂÖ∂‰ªñÁºìÂ≠òÈÄâÈ°πÈªòËÆ§ÈÖçÁΩÆÂèØÂèÇËÄÉ https://developer.chrome.com/docs/workbox/modules/workbox-recipes ÂèØÊûÅÂ§ßËäÇÁúÅÈÖçÁΩÆÊó∂Èó¥
// Âè™ÈúÄÂáÜÂ§á‰∏Ä‰∏™Âêç‰∏∫ offline.html ÁöÑÁ¶ªÁ∫ø HTML È°µÈù¢ÔºåÂπ∂Â∞ÜÂÖ∂ÊîæÁΩÆÂú®ÁΩëÁ´ôÊ†πÁõÆÂΩï‰∏ã„ÄÇ

// workbox.routing.setDefaultHandler(new workbox.strategies.NetworkFirst());
// workbox.recipes.offlineFallback();

// Á¶ªÁ∫øÈ°µÈù¢ÁºìÂ≠ò
// workbox.recipes.offlineFallback();
// URL navigation ÁºìÂ≠ò
// workbox.recipes.pageCache();

// html ÁöÑÁºìÂ≠ò
// HTMLÔºåÂ¶ÇÊûú‰Ω†ÊÉ≥ËÆ©È°µÈù¢Á¶ªÁ∫øËÉΩÂ§üÊãúËÆøÔºåÂ∫îÁî® NetworkFirstÔºåÂ¶ÇÊûú‰∏çÈ°ªË¶ÅÁ¶ªÁ∫øÊãúËÆøÔºåÂ∫îÁî® NetworkOnlyÔºåÂÖ∂‰ΩôÁ≠ñÁï•Âùá‰∏çÂÄ°ËÆÆÂØπ HTML Â∫îÁî®„ÄÇ
workbox.routing.registerRoute(new RegExp(/.*\.html/), new workbox.strategies.NetworkOnly());

// ‰∏Ä‰∫õÁºìÂ≠òÂ∞èÁ≠ñÁï•
// workbox.recipes.pageCache();
// workbox.recipes.googleFontsCache();
// workbox.recipes.staticResourceCache();
// workbox.recipes.imageCache();
// workbox.recipes.offlineFallback();

// ÊöñÁ≠ñÁï•ÁºìÂ≠ò
// This can be any strategy, CacheFirst used as an example.

// const strategy = new workbox.strategies.StaleWhileRevalidate();
// const urls = ['/offline/index.html'];
// workbox.recipes.warmStrategyCache({urls, strategy});


// Images
// workbox.routing.registerRoute(
//     /\.(?:png|jpg|jpeg|gif|bmp|webp|svg|ico)$/,
//     new workbox.strategies.CacheFirst({
//         cacheName: "images",
//         plugins: [
//             new workbox.expiration.ExpirationPlugin({
//                 maxEntries: 50,
//                 maxAgeSeconds: 60 * 60 * 24 * 365
//             }),
//             new workbox.cacheableResponse.CacheableResponsePlugin({
//                 statuses: [0, 200]
//             })
//         ]
//     })
// );

// CDN
workbox.routing.registerRoute(
    /.*\.(?:js|css)$/,
    new workbox.strategies.StaleWhileRevalidate({
        cacheName: 'ÈùôÊÄÅËµÑÊ∫ê',
        plugins: [
            new workbox.expiration.ExpirationPlugin({
                maxEntries: 60,
                maxAgeSeconds: 60 * 60 * 24
            }),
            new workbox.cacheableResponse.CacheableResponsePlugin({
                statuses: [0, 200]
            })
        ]
    })
);

workbox.routing.registerRoute(
    /.*\.(?:woff2)$/,
    new workbox.strategies.StaleWhileRevalidate({
        cacheName: 'Â≠ó‰ΩìÁºìÂ≠ò',
        plugins: [
            new workbox.expiration.ExpirationPlugin({
                maxEntries: 10,
                maxAgeSeconds: 60 * 60 * 24 * 7
            }),
            new workbox.cacheableResponse.CacheableResponsePlugin({
                statuses: [0, 200]
            })
        ]
    })
);

// Cache CSS, JS, and Web Worker requests with a Stale While Revalidate strategy

// workbox.routing.registerRoute(
//     ({ request }) =>
//         request.destination === 'style' ||
//         request.destination === 'script',
//         // ||
//         // request.destination === 'worker',
//     new workbox.strategies.StaleWhileRevalidate({
//         cacheName: 'ÈùôÊÄÅËµÑÊ∫ê',
//         plugins: [
//             new workbox.expiration.ExpirationPlugin({
//                 maxEntries: 100,
//                 maxAgeSeconds: 60 * 60 * 24,
//                 purgeOnQuotaError: true
//             }),
//             new workbox.cacheableResponse.CacheableResponsePlugin({
//                 statuses: [0, 200]
//             })
//         ]
//     })
// );

// Cache CSS, JS, and Web Worker requests with a Stale While Revalidate strategy

// workbox.routing.registerRoute(
//     ({ request }) =>
//         request.destination === 'style' ||
//         request.destination === 'script',
//         // ||
//         // request.destination === 'worker',
//     new workbox.strategies.StaleWhileRevalidate({
//         cacheName: 'ÈùôÊÄÅËµÑÊ∫ê',
//         plugins: [
//             new workbox.expiration.ExpirationPlugin({
//                 maxEntries: 100,
//                 maxAgeSeconds: 60 * 60 * 24,
//                 purgeOnQuotaError: true
//             }),
//             new workbox.cacheableResponse.CacheableResponsePlugin({
//                 statuses: [0, 200]
//             })
//         ],
//     }),
// );

// Fonts
// workbox.routing.registerRoute(
//     /\.(?:eot|ttf|woff|woff2)$/,
//     new workbox.strategies.CacheFirst({
//         cacheName: "fonts",
//         plugins: [
//             new workbox.expiration.ExpirationPlugin({
//                 maxEntries: 50,
//                 maxAgeSeconds: 60 * 60 * 24 * 30
//             }),
//             new workbox.cacheableResponse.CacheableResponsePlugin({
//                 statuses: [0, 200]
//             })
//         ]
//     })
// );

// Google Fonts
// workbox.routing.registerRoute(
//     /^https:\/\/fonts\.googleapis\.com/,
//     new workbox.strategies.StaleWhileRevalidate({
//         cacheName: "Ë∞∑Ê≠åÂ≠ó‰Ωì"
//     })
// );
// workbox.routing.registerRoute(
//     /^https:\/\/fonts\.gstatic\.com/,
//     new workbox.strategies.StaleWhileRevalidate({
//         cacheName: 'Ë∞∑Ê≠åÂ≠ó‰Ωì',
//         plugins: [
//             new workbox.expiration.ExpirationPlugin({
//                 maxEntries: 3,
//                 maxAgeSeconds: 60 * 60 * 24 * 30,
//                 purgeOnQuotaError: true
//             }),
//             new workbox.cacheableResponse.CacheableResponsePlugin({
//                 statuses: [0, 200]
//             })
//         ]
//     })
// );

// Static Libraries
// workbox.routing.registerRoute(
//     /^https:\/\/cdn\.jsdelivr\.net/,
//     new workbox.strategies.CacheFirst({
//         cacheName: "static-libs",
//         plugins: [
//             new workbox.expiration.ExpirationPlugin({
//                 maxEntries: 50,
//                 maxAgeSeconds: 60 * 60 * 24 * 30
//             }),
//             new workbox.cacheableResponse.CacheableResponsePlugin({
//                 statuses: [0, 200]
//             })
//         ]
//     })
// );

// workbox.googleAnalytics.initialize();

// const cdn = {
//     gh: {
//         // jsdelivr: 'https://cdn.jsdelivr.net/gh',
//         gcore: 'https://gcore.jsdelivr.net/gh',
//         fastly: 'https://fastly.jsdelivr.net/gh',
//         testingcf: 'https://testingcf.jsdelivr.net/gh',
//         test1: 'https://test1.jsdelivr.net/gh'
//     },
//     combine: {
//         // jsdelivr: 'https://cdn.jsdelivr.net/combine',
//         gcore: 'https://gcore.jsdelivr.net/combine',
//         fastly: 'https://fastly.jsdelivr.net/combine',
//         testingcf: 'https://testingcf.jsdelivr.net/combine',
//         test1: 'https://test1.jsdelivr.net/combine'
//     },
//     npm: {
//         // jsdelivr: 'https://cdn.jsdelivr.net/npm',
//         eleme: 'https://npm.elemecdn.com',
//         gcore: 'https://gcore.jsdelivr.net/npm',
//         fastly: 'https://fastly.jsdelivr.net/npm',
//         unpkg: 'https://unpkg.com',
//         testingcf: 'https://testingcf.jsdelivr.net/npm',
//         test1: 'https://test1.jsdelivr.net/npm'
//     }
// }

// self.addEventListener('install', async () => {
//     await self.skipWaiting()
// })

// self.addEventListener('activate', async () => {
//     await self.clients.claim()
// })

// self.addEventListener('fetch', async (event) => {
//     try {
//         // Â¶ÇÊûúÁî®Êà∑ÂΩìÂâçÁΩëÈÄüÊÖ¢ÔºåÊàñÊòØÂºÄÂêØ‰∫ÜÁúÅÊµÅÊ®°ÂºèÔºåÂàô‰∏ç‰ΩøÁî®swÂ§ÑÁêÜËØ∑Ê±Ç
//         const nav = navigator
//         const { saveData, effectiveType } = nav.connection || nav.mozConnection || nav.webkitConnection || {}
//         if (saveData || /2g/.test(effectiveType)) return

//         // Âä´ÊåÅËØ∑Ê±Ç
//         event.respondWith(handleRequest(event.request))
//         // eslint-disable-next-line
//     } catch (e) { }
// })

// // ËøîÂõûÂìçÂ∫î
// async function progress(res) {
//     return new Response(await res.arrayBuffer(), {
//         status: res.status,
//         headers: res.headers
//     })
// }

// function handleRequest(req) {
//     const urls = []
//     const urlStr = req.url
//     let urlObj = new URL(urlStr)
//     // ‰∏∫‰∫ÜËé∑Âèñ cdn Á±ªÂûã
//     // ‰æãÂ¶ÇËé∑Âèñgh (https://cdn.jsdelivr.net/gh)
//     const path = urlObj.pathname.split('/')[1]

//     // ÂåπÈÖç cdn
//     for (const type in cdn) {
//         if (type === path) {
//             for (const key in cdn[type]) {
//                 const url = cdn[type][key] + urlObj.pathname.replace('/' + path, '')
//                 urls.push(url)
//             }
//         }
//     }

//     // Â¶ÇÊûú‰∏äÊñπ cdn ÈÅçÂéÜ ÂåπÈÖçÂà∞ cdn ÂàôÁõ¥Êé•Áªü‰∏ÄÂèëÈÄÅËØ∑Ê±Ç
//     if (urls.length) return fetchAny(urls)
//     throw new Error('failure')
// }

// // Promise.any ÁöÑ polyfill
// function createPromiseAny() {
//     Promise.any = function (promises) {
//         return new Promise((resolve, reject) => {
//             promises = Array.isArray(promises) ? promises : []
//             let len = promises.length
//             let errs = []
//             if (len === 0) return reject(new AggregateError('All promises were rejected'))
//             promises.forEach((p) => {
//                 if (p instanceof Promise) {
//                     p.then(
//                         (res) => resolve(res),
//                         (err) => {
//                             len--
//                             errs.push(err)
//                             if (len === 0) reject(new AggregateError(errs))
//                         }
//                     )
//                 } else {
//                     reject(p)
//                 }
//             })
//         })
//     }
// }

// // ÂèëÈÄÅÊâÄÊúâËØ∑Ê±Ç
// function fetchAny(urls) {
//     // ‰∏≠Êñ≠‰∏Ä‰∏™ÊàñÂ§ö‰∏™ËØ∑Ê±Ç
//     const controller = new AbortController()
//     const signal = controller.signal

//     // ÈÅçÂéÜÂ∞ÜÊâÄÊúâÁöÑËØ∑Ê±ÇÂú∞ÂùÄËΩ¨Êç¢‰∏∫promise
//     const PromiseAll = urls.map((url) => {
//         return new Promise((resolve, reject) => {
//             fetch(url, { signal })
//                 .then(progress)
//                 .then((res) => {
//                     const r = res.clone()
//                     if (r.status !== 200) reject(null)
//                     controller.abort() // ‰∏≠Êñ≠
//                     resolve(r)
//                 })
//                 .catch(() => reject(null))
//         })
//     })

//     // Âà§Êñ≠ÊµèËßàÂô®ÊòØÂê¶ÊîØÊåÅ Promise.any
//     if (!Promise.any) createPromiseAny()

//     // Ë∞ÅÂÖàËøîÂõû"ÊàêÂäüÁä∂ÊÄÅ"ÂàôËøîÂõûË∞ÅÁöÑÂÜÖÂÆπÔºåÂ¶ÇÊûúÈÉΩËøîÂõû"Â§±Ë¥•Áä∂ÊÄÅ"ÂàôËøîÂõûnull
//     return Promise.any(PromiseAll)
//         .then((res) => res)
//         .catch(() => null)
// }